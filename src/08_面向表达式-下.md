# 面向表达式(下)-表达式分类
`Rust` 是一门没有垃圾回收的语言，它不像有垃圾回收语言那样，在使用的过程中不用太关心底层的内存管理。有垃圾回收的语言一般是内存安全的，但是内存管理对于开发者来说是不透明的，底层控制力和性能又不是很好。`Rust`也不像`C`和`C++`那样有显示的内存分配和内存管理函数，让开发者通过内存管理函数直观地了解内存管理状况，`C` 和 `C++` 的底层控制力比有`GC`的语言更好，但内存安全却比较困难。`Rust`可以保证内存安全的本质原因是依赖类型系统对值类型的各种检查。

## Rust 中表达式的分类
![expression](../img/expression.jpg)
这张图中表示`Rust`表达式分为`位置表达式`和`值表达式`。`Rust`没有继承左值和右值的术语，而是重新命名的位置表达式和值表达式。第一、对位置表达式求值可以得到代表内存位置的值，通过这个值就可以得到内存地址。第二、对值表达式求值得到的是从属于内存位置本身的值。表达式的求值既依赖于自身的类别也依赖于上下文。

### 表达式背后的内存管理
上面这行`let`表达式的本质，如下图
![expression_nature](../img/expression_nature.jpg)
位置表达式`answer`得到一个代表位置的值，值表达式自变量`42`得到一个数据值`42`。通过位置的值存入内存空间中的某个位置中。

操作系统的内存存储空间分为栈内存、堆内存、静态存储空间。数据具体可以存储在哪个内存位置还需要看值表达式的类型，所以在上图中赋值表达式的`answer`变量有一个专门的术语叫做`绑定`，它表示把内存位置和数据绑定在了一起，并且它还有对内存位置的管理权。

### let 绑定
`let`绑定原理如下图
![let_binding](../img/let_binding.jpg)

### 位置表达式
1. `let` 表达式。 如：`let answer = 42;`
2. 静态变量初始化。如：`static mut LEVELS: u32 = 0;`
3. 解引用表达式。形如 `*expr`
4. 数组索引表达式。形如 `expr[expr]`
5. 字段表达式。 形如 `expr. field`
6. 以及，加上括号的位置表达式，形如 `( expr)`

***除此之外的，都是值表达式。***

### 位置上下文
1. 赋值左侧上下文和复合赋值操作；
```
let mut a = 1;  // 赋值操作 = 左侧的 mut a 是位置上下文
a += 1; // += 是复合赋值操作，a += 左侧的a 是位置上下文
```
2. 一元「借用」和「解引用」操作中的操作数所在区域。
```
let a = &mut 7; // 定义的 a 是一个对数字的可变借用，a 右侧就是位置上下文；
*a = 42; // *a 就是解引用操作，它代表的就是位置上下文
let b = &a;
```
3. 字段表达式的操作数所在区域
```
struct A {
  name: &'static str,
}

let a = A {name: "Alex"};
a.name // A 的实例 a 来获取Struct的字段，这个字段所在的区域(name)就是位置上下文
}
```
4. 数组索引表达式的操作数所在区域
```
let mut a = [1, 2, 3];
let b = &mut a;
a[1] = 42; // 取数组索引为1的数据 a[1] 这个就是位置上下文
```
5. 任意隐式借用操作数所在区域
```
let mut v = vec![1, 2, 3];
v.push(4); // push 方法调用会隐式借用 &mut v， 这个就是位置上下文
```
6. let 语句初始化
```
let a: i32; // 初始化变量a，但是没有给它赋值，这里就是位置上下文
a = 42;
```
7. if let / while let/ match 的匹配表达式所在区域
```
let dish = ("Ham", "Eggs");
if let ("Bacon", b) = dish { // 匹配表达式("Bacon", b) 所在区域就是位置上下文，通过得到内存位置上的"Ham"和"Bacon" 进行比较
  println!("Bacon is served with {}", b);
else {
  println!("No bacon will be served");
}

// 同理
while let (位置上下文) = {...}
match (位置上下文) {...}
```
8. 结构体更新语法中的 base 表达式(..操作符后面的操作数区域)
```
let mut base = Point3d {x: 1, y: 2, x: 3};
let y_ref = &mut base.y;
Point3d {y: 0, z: 10, ..base}; // 得到 base.x 这里就是位置上下文
```
***其它的都是值上下文***
## Rust 所有权语义在 表达式上 的体现
### 当位置表达式出现在了值上下文中
```
let stack_a = 42; // stack_a 是位置表达式，42 实现了 Copy，42 这个值会存储在栈内存中；
let stack_b = stack_a; // stack_a 出现在值上下文，stack_a 发生 Copy
stack_a; ok

let heap_a = "hello".to_string(); // heap_a 是位置表达式，"hello".to_string() 没有实现 Copy，会存储在堆内存中，栈内存上会存储它的引用指针
let heap_b = heap_a; // heap_a 出现在值上下文，此时 heap_a 发生 Move，堆中 "hello".to_string() 不会发生变化，栈中指向 heap_a 的指针会指向 heap_b
heap_a; // error 栈上指向 heap_a 的指针已经指向的 heap_b，heap_a 报错
```
### Copy 语义
Copy 语义代表可以安全在栈内存复制
![copy_semantic](../img/copy_semantic.jpg)
### Move 语义
Move 语义代表必须旧的绑定失效，避免内存不安全
![move_semantic](../img/move_semantic.jpg)
## 不可变与可变
`Rust` 借鉴了函数式语言的不可变特性，包括：不可变绑定与可变绑定。不可变引用与可变引用
### 不可变绑定
在`Rust`中定义一个变量，默认是不可变的。
```
let answer = 42;
```
这段代码中定义的变量`answer`默认不可变，即，`answer`背后的内存位置上的数据不允许改变，给它赋值新的数据，编译器会报错，不允许给不可变的变量`answer`赋值两次，这样的绑定叫不可变绑定。

若修改这个变量的值，可以定义两个同名的变量绑定，但是赋予不同的值
```
let answer = 42;
let answer = 43;
```
这种方式叫`继承式可变`或`变量遮蔽`，实质上这是两个不同的变量，只是变量名相同而已；
### 可变绑定
使用 mut 修饰符将变量声明为可变绑定
```
let mut answer = 42;
```
### 不可变引用
不可变引用又叫共享引用。无论是可变绑定还是不可变绑定，因为`Rust`内存机制，每个内存位置只允许唯一的绑定存在。`Rust`中支持`C`语言的`*const T`和`*mut T`的原始指针，但是这些只能在 `Unsafe Rust`中对这种原始指针进行操作。`Rust`认为这种原始指针是不安全的，使用它们容易引起内存不安全问题。所以在`Safe Rust`中通常使用引用。
```
let answer = 42; // 定义变量 answer
let r = &answer;
```
定义变量 `r`，同时使用引用操作符 `&` 对 `answer` 进行引用将其赋值给 `r`。这个引用本身是一个地址指针，但是它比指针多了很多安全检查。从内存中得到了内存地址，但是这个内存地址是不可变引用，所以不可以对这个内存地址中的数据进行更改。
### 可变引用
也叫独占引用
```
let mut answer = 42;
let r = &mut answer; // 使用引用操作符 & 与 可变修饰符 mut 就使得变量 r 获得了变量 answer 的可变引用；
*r = 43;
println!("{}", answer);
```
**变量引用可以同时有多个，因为它不能修改内存保存的数据。但是可变引用只有有一个，因为它可以修改内存保存的数据，所以需要保持独占性，保证内存安全。可变引用像一把内存锁，拿到可变引用后才可以修改**
