# 面向表达式(上)-语法一致性
## 表达式和语句

广义角度讲每行代码都可以看作是一个语句，这行代码一定会做某些事情。

### 语句的四种类型
1. 声明语句，声明语言一些基本要素。如：定义结构体、定义函数、引入模块、赋值等。
2. 流程控制语句。如：条件分支、循环、case 语句等。
3. 表达式语句，专门用来产生值的一种构造式，即这条语句是专门用来求值的。
4. 宏语句，专门用来文本替换或生成指定代码

## Rust 语法骨架
```
#![...]
...;
... {
  ...;
}
... {
  ...;
  ...
}
... {
  ...;
  ...;
}
```
`Rust`语法骨架主要由以下三个着关键元素组成
* 属性，类似于 #![...]
* 分号「;」，行分隔符
* 花括号「{...}」，块分隔符

## 面向表达式的语言
Rust 语言借鉴了函数式语言，面向表达式，即整个计算过程都是通过计算表达式进行求值，而不是通过语句来修改某个状态。分号 和 块，是 Rust 语言的两个基本表达式

### 分号表达式
分号表达式可以产生一种叫`单元类型`的值，也可以称被`unit`，它的值就是它自身，也就是`()`，一个空元组。它只有在块表达式的最后一行才求值。

### 块表达式
块中最后一个表达式的值。由一对`{}`组成，内部可以有很多表达式的表达式，其返回值是最后一条表达式求值的返回值；

### 求值规则
1. 分号表达式返回值是永远为自身的单元(Unit)类型:`()`。
2. 分号表达式只有在块表达式最后一行才会进行求值， 其他时候只作为`连接符`存在。
3. 块表达式只对其最后一行表达式进行求值。
```
fn main{
  ;
  ;
  {
    ()
  }
  {
    ();
    use std::vec::Vec;
  }
  ();
  &{;}; // -> &()
  ; // -> ()
  ;
}
```
说明：
* `main`函数本身就是一个大的块表达式，此处的 `main` 函数签名没有明确标出返回值，所以它默认返回单元类型；
* `main`函数值的最后一行`;`是一个表达式，它会进行求值，返回一个单元值的类型，这是 `main`函数的返回值；
* `main`函数中除最后一个分号表达式外，上面所有的分号都是作为链接符存在；
* `main`函数内行代码用分号分隔，多条行代码组成的语句块使用块表达式分隔；
* `main`函数内的块表达式遵循同样规则；
* `main`函数内的第二个块语句最后一行是`use`声明语句且以分号结尾，这表示它会返回单元值类型；
* `main`函数引`&{;};`带引用操作符的的块表达式最终会返回一个单元值的引用。因为块表达式会返回一个单元值，而它与引用操作符`&`结合，最后产生单元值的引用；
* 无法直接对分号表达式进行引用来获得一个单元值的引用类型，这样的语法不满足规则，只能使用块表达式来达成目的；
### 另一种划分方式
基本语句和表达式。每一行带分号的代码都可以看作是一个返回单元值，把这样的代码就叫做语句。单元值本身没有任何意义。
1. 基本语句
* 声明语句，如：`use std::vec::Vec;`
* 表达式语句，用来求值的语句就是表达式语句，表达式就是不加分号的表达式，用作求值并返回。
2. 表达式
* 块中最后一行不加分号的表达式
```
fn plus_one(i: &u32) -> u32 {
  let i = i + 1;
  i
}
```
上面函数，即块表达式返回`u32`类型，在块表达式内最后一行表达式进行求值并返回，这时最后一行表达式不需要加分号，否则返回的就是单元值。

**`Rust`中一切都是表达式。`Rust`中除了基本的引用语句，其它的都是表达式，如自变量、路径、数组、结构体、枚举、函数闭包、方法调用、字段访问、操作符、流程控制等。**

流程控制也是表达式
```
fn main() {
  for i in 1..102 {
    if i % 15 == 0 { println!("FizzBuzz"); }
    else if i % 3 == 0 { println!("Fizz"); }
    else if i % 5 == 0 { println!("Buzz"); }
    else { println!("{}", i); }
  }
}
```
`for`循环表达式默认返回单元类型，`if ... else...`虽然有多行，但是它属于一整个表达式，默认依然返回单元类型，每一个 `if ... else ...` 分支的返回值类型必须一致；
